# 0. URL 입력부터 리퀘스트 송수신까지
1. 사용자가 URL을 입력한다.
2. 입력된 URL은 규칙(프로토콜)에 따라 해석된다.
3. URL에 적힌 도메인 이름을 DNS 서버에 의뢰한다.
4. DNS 서버가 IP 주소를 반환한다.
5. Socket 프로토콜이 IP 주소로 HTTP 리퀘스트를 송신한다.
6. 서버측에서 Socket 연결을 준비한다.
7. 클라이언트 측에서 Socket을 연결한다.
8. 연결된 Socket으로 데이터를 송수신한다.
9. 데이터 교환이 끝나면 `close`한다.

좀 더 축약해서 설명하면 이렇다.</br>

1. 브라우저가 URL을 해독한다.
2. DNS 서버에 도메인 이름에 해당하는 IP 주소를 요청한다.
3. HTTP 메세지를 생성하고, OS에 의뢰하여 송신한다.

브라우저에게 네트워크 송출 기능은 없고, 네트워크 송출 기능은 **OS(운영체제)** 고유 권한이다.

# 1. HTTP 리퀘스트 메세지 작성
0~1번에 해당하는 내용이다.</br>
## 1-1. URL의 구조
URL(Uniform Resource Locator)은 서버에 접속할 수 있는 일종의 주소로, 흔히들 아는 "http:www.naver.com" 등의 웹 서버 주소 이 외에도 여러가지가 있다. URL을 통해 어떤 서버에 접속할 지를 결정할 수 있는데, 기본적으로 **액세스 방법(프로토콜 종류) + 접근 정보**로 구성되어 있다.</br>
- http:www.naver.com -> HTTP 프로토콜로 웹 서버 접근
- file://localhost/c:/path/java1.zip -> PC에서 파일 접근

이 외에도 많은데, 생략한다. 아무튼 URL의 가장 첫 단어로 어떤 종류의 프로토콜을 사용할 것인지 정할 수 있고, 그 뒤에는 해당 프로토콜에 따른 작성 방식을 따른다.</br>
`http` 프로토콜은 웹 서버에 접근하는 프로토콜이다. 그 뒤의 `www.naver.com`은 **웹 서버 이름 + (디렉토리 + 파일명)** 으로 이루어져 있다. 여기서 웹 서버는 `www.naver.com`이고, (디렉토리 + 파일명)은 적지 않았다. 적지 않으면 서버 측에서 지정한 `default.html` 등의 루트 디렉토리 아래의 디폴트 파일이 호출되어 수신된다.
</br>

## 1-2. HTTP 프로토콜
URL이 해석되면 **HTTP 프로토콜**을 따라 웹 서버에 액세스한다. 프로토콜이라는 이름에서 알 수 있듯이, 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것이다.</br>

클라이언트는 HTTP 리퀘스트 메세지에 `URI`와 `메소드`를 포함시켜 서버측으로 보낸다. **URI(Uniform Resource Identifier)**는 액세스 대상을 통칭하는 말이고, **메소드**는 웹 서버에서 어떤 동작을 하고 싶은지를 뜻한다.</br>

서버측에서 클라이언트가 보낸 HTTP 리퀘스트 메세지를 수신하고, 데이터를 처리한 뒤 클라이언트에게 다시 보내주는 것을 HTTP 리스폰스(Response)라고 한다. 응답의 맨 앞부분에는 요청 처리가 어떻게 이루어졌는지 알려주는 **스테이터스 코드(Status Code)** 가 적혀있다. 브라우저는 응답 메세지를 받고, 브라우저가 메세지 내부의 데이터를 추출, 해석하여 화면에 표시(Rendering)해준다.</br>

메소드에는 GET, POST, PUT, DELETE 등이 있다.

</br>

# 2. DNS 서버에 IP 주소 의뢰
3~4번에 해당하는 내용이다.</br>

## 2-1. TCP/IP의 구조
**허브(Hub)** 를 통해 연결된 몇 대의 PC를 **서브 넷**이라고 한다. 네트워크(Network)는 여러 **서브넷**이 **라우터(Router)** 로 연결된 것을 의미한다. 라우터와 허브는 패킷 중계 장치의 일종이다. **IP 주소**는 **네트워크 번호**와 **호스트 번호**의 합이다.</br>
**IP 주소**는 32비트의 디지털 데이터인데, 네트워크 번호와 호스트 번호를 어떻게 합칠지는 사용자의 결정 사항이다. 따라서 **어디까지가 네트워크 번호이고, 어디까지가 호스트 번호인지 알려주는 정보**가 필요하다. 이 역할을 수행하는 것이 **넷마스크**이다.</br>
넷마스크가 모두 0이면 서브넷 자체를 의미하고, 모두 1이면 서브넷 전체 기기에 패킷을 보내는 **브로드캐스트**를 의미한다.

## 2-2. IP 주소 찾기
**DNS(Domain Name System)** 는 이름을 알려주면 IP 주소를 알려주고, IP 주소를 알려주면 도메인 이름을 알려준다. 이는 전화번호부에 이름과 번호를 저장하는 것과 유사하다. 사람은 이름으로 상대방을 인식하지만, 기계는 번호를 통해 상대방에게 전화를 요청할 수 있다. 도메인은 이름, IP 주소는 번호에 해당한다.</br>

브라우저는 어떻게 DNS 서버를 조회할 수 있을까? **DNS 리졸버**, 혹은 **리졸버**를 통해 IP를 조사하는 **네임 레졸루션(Name Resolution, 이름 확인)** 을 통해 가능하다. DNS 레졸버는 **레졸루션**을 실행시킨다. </br>

리졸버는 **Socket 라이브러리** 내부의 프로그램이다. 이 때, DNS 서버에 요청을 보내는 것도 네트워크 송수신 기능이므로, 브라우저가 수행하지 못한다. 대신 OS 내부에 포함된 **프로토콜 스택**에게 제어권을 넘겨 수행할 수 있다.</br>

DNS 서버의 IP 주소는 OS에 저장되어 있다.

## 2-3. DNS 서버 탐색
DNS 서버에 도메인에 해당하는 IP 주소 조사를 요청했지만, 전세계 DNS 서버를 일일이 다 뒤질 순 없는 노릇이다. 따라 `.`을 통해 도메인 계층 구조를 형성하고, 이를 통해 효과적으로 탐색할 수 있다.</br>
DNS 서버는 **캐시** 기능을 이용하여, 한 번 조사한 이름이 또 다시 요청되면 곧바로 회답할 수 있다. 이 때, 캐시는 서버에 소속된 메모리가 아니므로 데이터 무결성 문제가 있다. 따라서 캐시 저장 데이터는 유효기간이 존재한다.

</br>

# 3. 프로토콜 스택에 메세지 송신 의뢰
DNS 서버가 응답 메세지에 IP 주소를 저장하여 돌려주면, IP 주소는 사용자 PC의 메모리에 저장된다. 이제 이 IP 주소를 통해 엑세스 하고싶은 웹 서버에 **HTTP 리퀘스트 메세지**를 보낼 수 있다. 이 때에도, OS에 소속된 프로토콜 스택이 네트워크 송수신 역할을 수행한다.</br>

HTTP 요청이 웹 서버에 전송되어 승인이 되면, 웹 서버와 클라이언트는 **소켓**을 통해 데이터 교환을 할 수 있다.

1. 웹 서버에서 먼저 소켓을 만들어 연결한다.
2. 클라이언트에서 소켓을 만들어 연결한다.
3. 소켓을 통해 데이터 송수신 동작을 수행한다.

## 3-1 클라이언트 측 소켓 생성
클라이언트는 복수의 소켓을 생성할 수 있다. 크롬창 여러개를 띄어놓는 게 그런 경우다. 이 경우 어떤 소켓이 어떤 브라우저에 해당하는지를 구분해야 한다. **디스크립터**는 소켓을 식별하기 위한 정보이다. 프로토콜 스택은 디스크립터를 통해 어느 소켓을 사용할지, 데이터를 송수신할 지를 판단할 수 있다.</br>

## 3-2 클라이언트-서버 소켓 연결
클라이언트가 생성한 소켓을 서버가 생성한 소켓에 연결해야 데이터 교환이 가능하다. **프로토콜 스택**은 Socket 라이브러리의 `connect`를 호출하고, 이 때 **디스크립터**, **서버 IP 주소**, **포트 번호**를 전달해준다.</br>

**디스크립터**는 클라이언트가 소켓을 생성할 때 돌려받은 것으로, 이를 통해 어떤 소켓을 어디에 연결할 지 판단할 수 있다.</br>
**IP 주소**는 DNS 서버에서 조회한 것으로, 네트워크에 존재하는 각 컴퓨터를 식별하기 위한 정보이다. 즉, 웹 서버와 클라이언트의 PC는 거대한 네트워크망을 통해 연결되어 있고, 웹 서버의 IP 주소를 통해 접근을 요청할 수 있다는 것이다.</br>
**포트 번호**는 IP 주소를 통해 접근한 PC 내부의 어떤 소켓에 연결할 지를 알려준다. 즉, 포트 번호는 상대방이 생성한 소켓을 식별하기 위한 정보이다.

## 3-3 데이터 교환
사용자가 URL을 통해 생성한 HTTP 리퀘스트 메세지를 소켓을 통해 전달한다. Socket 라이브러리의 `write`를 호출하여 디스크립터와 송신 데이터를 전달하고, 프로토콜 스택이 송신 데이터를 서버로 송신한다.</br>
서버가 요청을 받고 처리하여 응답할 때도 동일하다. 사용자는 서버의 응답을 `read` 프로그램을 통해 프로토콜 스택에 수신을 의뢰할 수 있다. 응답 메세지는 **수신 버퍼**라는 사용자 메모리 영역에 저장된다.</br>

## 3-4 연결 끊기 단계
데이터 교환이 완료되면 Socket 라이브러리는 `close`를 호출하여 연결을 끊는다. 주로 웹 서버측에서 `close`를 통해 연결을 끊고, 이 사실이 클라이언트에게 전달된다. 클라이언트의 소켓 또한 `close`를 통해 소멸하고, 브라우저가 `read`를 의뢰할 때 데이터 대신 연결 종료 사실을 전달받는다. 그럼 브라우저도 `close`를 호출해 연결을 끊는다.</br>

## 3-5 복수의 데이터 교환
원론적으로 HTTP 리퀘스트는 한 번의 요청에 한 번의 응답만 가능하였다. 즉, 웹 페이지에 5개의 자료가 있다면 총 5번의 데이터 송수신 과정이 이루어져야 한다는 것이다. 하지만 이는 비효율적으로, HTTP 1.1 버전부터는 연결을 끊지 않고도 복수의 리퀘스트와 응답을 주고받을 수 있는 기능을 지원하고 있다.